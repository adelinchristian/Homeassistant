blueprint:
  name: Advanced Unavailable Device Monitor (Production, GitHub Import)
  description: >
    Monitors selected domains for unavailable devices.
    Features: aggregation, per-domain grouping, severity levels,
    critical domain override, push/persistent notifications,
    auto-dismiss persistent notifications, clickable entity links, timestamps.
  domain: automation

  input:
    monitored_domains:
      name: Monitored domains
      default:
        - sensor
        - light
        - switch
      selector:
        select:
          multiple: true
          options:
            - sensor
            - light
            - switch
            - binary_sensor
            - climate
            - cover
            - fan
            - lock
            - media_player
            - number
            - select
            - update
            - siren
            - camera

    critical_domains:
      name: Critical domains
      description: Always push notifications for these domains
      default:
        - lock
      selector:
        select:
          multiple: true
          options:
            - lock
            - climate
            - cover
            - alarm_control_panel
            - binary_sensor
            - camera
            - siren

    excluded_entities:
      name: Excluded entities
      default: []
      selector:
        entity:
          multiple: true

    unavailable_for:
      name: Unavailable duration
      default:
        minutes: 5
      selector:
        duration:

    aggregation_window:
      name: Aggregation window
      default:
        minutes: 10
      selector:
        duration:

    rate_limit:
      name: Rate limit interval
      default:
        hours: 1
      selector:
        duration:

    notification_mode:
      name: Notification mode
      default: both
      selector:
        select:
          options: [push, persistent, both]

    notify_service:
      name: Push notification service
      description: Push notification service (e.g., notify.mobile_app_phone)
      selector:
        text:

trigger:
  - platform: state
    to: unavailable

condition: []

action:
  # Runtime variables
  - variables:
      entity_id: "{{ trigger.entity_id }}"
      domain: "{{ trigger.entity_id.split('.')[0] }}"
      name: "{{ state_attr(trigger.entity_id,'friendly_name') or trigger.entity_id }}"
      monitored_domains: !input monitored_domains
      critical_domains: !input critical_domains
      excluded_entities: !input excluded_entities
      unavailable_for: !input unavailable_for
      aggregation_window: !input aggregation_window
      rate_limit: !input rate_limit
      notification_mode: !input notification_mode
      # Safe fallback for rate limit
      last_triggered_safe: >
        {{ this.last_triggered if this.last_triggered is not none else now() - rate_limit - 1 }}

  # Skip if entity is excluded or domain not monitored
  - condition: template
    value_template: "{{ domain in monitored_domains and entity_id not in excluded_entities }}"

  # Delay to confirm unavailable
  - delay: !input unavailable_for

  # Confirm still unavailable
  - condition: template
    value_template: "{{ states(entity_id) == 'unavailable' }}"

  # Wait for aggregation window to collect multiple events
  - wait_for_trigger:
      - platform: event
        event_type: state_changed
    timeout: !input aggregation_window
    continue_on_timeout: true

  # Build domain-level list of unavailable entities
  - variables:
      unavailable_entities: >
        {{ states
           | selectattr('domain','eq',domain)
           | selectattr('state','eq','unavailable')
           | rejectattr('entity_id','in',excluded_entities)
           | map(attribute='entity_id')
           | list }}

      count: "{{ unavailable_entities | length }}"

      severity: >
        {% if domain in critical_domains %}
          emergency
        {% elif count >= 5 %}
          critical
        {% elif count >= 2 %}
          warning
        {% else %}
          info
        {% endif %}

      severity_icon: >
        {% if severity == 'emergency' %}ðŸ”´
        {% elif severity == 'critical' %}ðŸŸ 
        {% elif severity == 'warning' %}ðŸŸ¡
        {% else %}ðŸŸ¢
        {% endif %}

      entity_lines: >
        {{ unavailable_entities
           | map('regex_replace','^(.*)$','[\\1](/config/entities/\\1) â€” ' ~ now().strftime('%H:%M')) 
           | list }}

  # Logbook entry (entity_id removed)
  - service: logbook.log
    data:
      name: "Devices unavailable"
      message: "{{ name }} is unavailable"

  # Persistent notification
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ notification_mode in ['persistent','both'] }}"
        sequence:
          - service: persistent_notification.create
            data:
              notification_id: "unavailable_{{ domain }}"
              title: "{{ severity_icon }} {{ domain | title }} unavailable ({{ severity | upper }})"
              message: >
                {{ count }} entities unavailable:
                {% for line in entity_lines %}
                {{ line }}
                {% endfor %}

      # Push notification with safe rate-limit
      - conditions:
          - condition: template
            value_template: >
              {{ notification_mode in ['push','both'] and
                 (domain in critical_domains or severity in ['critical','emergency'] or
                 (now() - last_triggered_safe) > rate_limit) }}
        sequence:
          - service: "{{ notify_service }}"
            data:
              title: "{{ severity_icon }} {{ domain | title }} unavailable"
              message: "{{ count }} entities unavailable ({{ severity }})"

mode: restart
max: 20
